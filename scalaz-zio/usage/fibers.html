<html><head><title>ZIO: Fibers</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="ZIO contributors" /><meta name="description" content="ZIO" /><meta name="og:image" content="/scalaz-zio/img/poster.png" /><meta name="og:title" content="ZIO: Fibers" /><meta name="og:site_name" content="ZIO" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="ZIO" /><link rel="icon" type="image/png" href="/scalaz-zio/img/favicon.png" /><meta name="twitter:title" content="ZIO: Fibers" /><meta name="twitter:image" content="img/poster.png" /><meta name="twitter:description" content="ZIO" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="512x512" href="/scalaz-zio/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalaz-zio/highlight/styles/default.css" /><link rel="stylesheet" href="/scalaz-zio/css/style.css" /><link rel="stylesheet" href="/scalaz-zio/css/palette.css" /><link rel="stylesheet" href="/scalaz-zio/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalaz-zio/" class="brand"><div class="brand-wrapper"><span>ZIO</span></div></a></li> <li><a href="/scalaz-zio/usage/index.html" class="">Usage</a> <ul class="sub_section"> <li><a href="/scalaz-zio/usage/main.html" class="">Main</a></li> <li><a href="/scalaz-zio/usage/purity.html" class="">Purity</a></li> <li><a href="/scalaz-zio/usage/mapping.html" class="">Mapping/Chaining</a></li> <li><a href="/scalaz-zio/usage/failure.html" class="">Failure</a></li> <li><a href="/scalaz-zio/usage/bracket.html" class="">Brackets</a></li> <li><a href="/scalaz-zio/usage/fibers.html" class=" active ">Fibers</a></li> <li><a href="/scalaz-zio/usage/performance.html" class="">Performance</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/scalaz/scalaz-zio"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/scalaz/scalaz-zio"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('ZIO ZIO');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('ZIO ZIO');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="scalaz" data-github-repo="scalaz-zio"><div class="content-wrapper"><section><h1 id="fibers">Fibers</h1>

<p>To perform an action without blocking the current process, you can use fibers, which are a lightweight mechanism for concurrency.</p>

<p>You can <code class="highlighter-rouge">fork</code> any <code class="highlighter-rouge">IO[E, A]</code> to immediately yield an <code class="highlighter-rouge">IO[Nothing, Fiber[E, A]]</code>. The provided <code class="highlighter-rouge">Fiber</code> can be used to <code class="highlighter-rouge">join</code> the fiber, which will resume on production of the fiber’s value, or to <code class="highlighter-rouge">interrupt</code> the fiber with some exception.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.zio._</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">analyzed</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">fiber1</span>   <span class="k">&lt;-</span> <span class="n">analyzeData</span><span class="o">(</span><span class="n">data</span><span class="o">).</span><span class="n">fork</span>  <span class="c1">// IO[E, Analysis]
</span>    <span class="n">fiber2</span>   <span class="k">&lt;-</span> <span class="n">validateData</span><span class="o">(</span><span class="n">data</span><span class="o">).</span><span class="n">fork</span> <span class="c1">// IO[E, Boolean]
</span>    <span class="o">...</span> <span class="c1">// Do other stuff
</span>    <span class="n">valid</span>    <span class="k">&lt;-</span> <span class="n">fiber2</span><span class="o">.</span><span class="n">join</span>
    <span class="k">_</span>        <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(!</span><span class="n">valid</span><span class="o">)</span> <span class="n">fiber1</span><span class="o">.</span><span class="n">interrupt</span><span class="o">(</span><span class="nc">DataValidationError</span><span class="o">(</span><span class="n">data</span><span class="o">))</span>
                <span class="k">else</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span>
    <span class="n">analyzed</span> <span class="k">&lt;-</span> <span class="n">fiber1</span><span class="o">.</span><span class="n">join</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">analyzed</span>
</code></pre></div></div>

<p>On the JVM, fibers will use threads, but will not consume <em>unlimited</em> threads. Instead, fibers yield cooperatively during periods of high-contention.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">IO</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">fiber1</span> <span class="k">&lt;-</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">).</span><span class="n">fork</span>
      <span class="n">fiber2</span> <span class="k">&lt;-</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="n">fork</span>
      <span class="n">v2</span>     <span class="k">&lt;-</span> <span class="n">fiber2</span><span class="o">.</span><span class="n">join</span>
      <span class="n">v1</span>     <span class="k">&lt;-</span> <span class="n">fiber1</span><span class="o">.</span><span class="n">join</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Interrupting a fiber returns an action that resumes when the fiber has completed or has been interrupted and all its finalizers have been run. These precise semantics allow construction of programs that do not leak resources.</p>

<p>A more powerful variant of <code class="highlighter-rouge">fork</code>, called <code class="highlighter-rouge">fork0</code>, allows specification of supervisor that will be passed any non-recoverable errors from the forked fiber, including all such errors that occur in finalizers. If this supervisor is not specified, then the supervisor of the parent fiber will be used, recursively, up to the root handler, which can be specified in <code class="highlighter-rouge">RTS</code> (the default supervisor merely prints the stack trace).</p>

<h1 id="error-model">Error Model</h1>

<p>The <code class="highlighter-rouge">IO</code> error model is simple, consistent, permits both typed errors and termination, and does not violate any laws in the <code class="highlighter-rouge">Functor</code> hierarchy.</p>

<p>An <code class="highlighter-rouge">IO[E, A]</code> value may only raise errors of type <code class="highlighter-rouge">E</code>. These errors are recoverable, and may be caught the <code class="highlighter-rouge">attempt</code> method. The <code class="highlighter-rouge">attempt</code> method yields a value that cannot possibly fail with any error <code class="highlighter-rouge">E</code>. This rigorous guarantee can be reflected at compile-time by choosing a new error type such as <code class="highlighter-rouge">Nothing</code>, which is possible because <code class="highlighter-rouge">attempt</code> is polymorphic in the error type of the returned value.</p>

<p>Separately from errors of type <code class="highlighter-rouge">E</code>, a fiber may be terminated for the following reasons:</p>

<ul>
  <li>The fiber self-terminated or was interrupted by another fiber. The “main” fiber cannot be interrupted because it was not forked from any other fiber.</li>
  <li>The fiber failed to handle some error of type <code class="highlighter-rouge">E</code>. This can happen only when an <code class="highlighter-rouge">IO.fail</code> is not handled. For values of type <code class="highlighter-rouge">IO[Nothing, A]</code>, this type of failure is impossible.</li>
  <li>The fiber has a defect that leads to a non-recoverable error. There are only two ways this can happen:
    <ol>
      <li>A partial function is passed to a higher-order function such as <code class="highlighter-rouge">map</code> or <code class="highlighter-rouge">flatMap</code>. For example, <code class="highlighter-rouge">io.map(_ =&gt; throw e)</code>, or <code class="highlighter-rouge">io.flatMap(a =&gt; throw e)</code>. The solution to this problem is to not to pass impure functions to purely functional libraries like Scalaz, because doing so leads to violations of laws and destruction of equational reasoning.</li>
      <li>Error-throwing code was embedded into some value via <code class="highlighter-rouge">IO.point</code>, <code class="highlighter-rouge">IO.sync</code>, etc. For importing partial effects into <code class="highlighter-rouge">IO</code>, the proper solution is to use a method such as <code class="highlighter-rouge">syncException</code>, which safely translates exceptions into values.</li>
    </ol>
  </li>
</ul>

<p>When a fiber is terminated, the reason for the termination, expressed as a <code class="highlighter-rouge">Throwable</code>, is passed to the fiber’s supervisor, which may choose to log, print the stack trace, restart the fiber, or perform some other action appropriate to the context.</p>

<p>A fiber cannot stop its own termination. However, all finalizers will be run during termination, even when some finalizers throw non-recoverable errors. Errors thrown by finalizers are passed to the fiber’s supervisor.</p>

<p>There are no circumstances in which any errors will be “lost”, which makes the <code class="highlighter-rouge">IO</code> error model more diagnostic-friendly than the <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">catch</code>/<code class="highlighter-rouge">finally</code> construct that is baked into both Scala and Java, which can easily lose errors.</p>

<h1 id="parallelism">Parallelism</h1>

<p>To execute actions in parallel, the <code class="highlighter-rouge">par</code> method can be used:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">bigCompute</span><span class="o">(</span><span class="n">m1</span><span class="k">:</span> <span class="kt">Matrix</span><span class="o">,</span> <span class="n">m2</span><span class="k">:</span> <span class="kt">Matrix</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Matrix</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Matrix</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">t</span> <span class="k">&lt;-</span> <span class="n">computeInverse</span><span class="o">(</span><span class="n">m1</span><span class="o">).</span><span class="n">par</span><span class="o">(</span><span class="n">computeInverse</span><span class="o">(</span><span class="n">m2</span><span class="o">))</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">i1</span><span class="o">,</span> <span class="n">i2</span><span class="o">)</span> <span class="k">=</span> <span class="n">t</span>
    <span class="n">r</span> <span class="k">&lt;-</span> <span class="n">applyMatrices</span><span class="o">(</span><span class="n">i1</span><span class="o">,</span> <span class="n">i2</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">r</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">par</code> combinator has resource-safe semantics. If one computation fails, the other computation will be interrupted, to prevent wasting resources.</p>

<h3 id="racing">Racing</h3>

<p>Two <code class="highlighter-rouge">IO</code> actions can be <em>raced</em>, which means they will be executed in parallel, and the value of the first action that completes successfully will be returned.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">action1</span><span class="o">.</span><span class="n">race</span><span class="o">(</span><span class="n">action2</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">race</code> combinator is resource-safe, which means that if one of the two actions returns a value, the other one will be interrupted, to prevent wasting resources.</p>

<p>The <code class="highlighter-rouge">race</code> and even <code class="highlighter-rouge">par</code> combinators are a specialization of a much-more powerful combinator called <code class="highlighter-rouge">raceWith</code>, which allows executing user-defined logic when the first of two actions succeeds.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalaz-zio/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script>((window.gitter = {}).chat = {}).options = {
room: 'scalaz/scalaz-zio'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalaz-zio/js/main.js"></script></body></html>